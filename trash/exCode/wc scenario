    def identify_worst_case_scenario(self):
        # create nominal model
        self.nom_mod = self.d_mod(self.nfe_t,self.ncp_t, s_max = 1, nr = 1)
        m = self.nom_mod
        m.name = "nominal model for computation of sensitivites with sIpopt"
        for i in m.eps.index_set():
            m.eps[i] = 0.0
        m.eps.fix()    
        m.create_bounds()
        delta_p = 1e-5
        state_suffix_map = m.construct_sensitivity_constraint(delta_p)

        # initialize by previous step? (open question)
        for var in m.component_objects(Var, active = True):
            var_ref = getattr(self.recipe_optimization_model, var.name)
            for key in var.index_set():
                var[key].value = var_ref[key].value   
        
        for u in self.u:
            control = getattr(m,u)
            control.fix()
        
        bounds = {}
        for x in self.states:
            x_var = getattr(self.recipe_optimization_model, x)
            for j in self.state_vars[x]:
                if j == (1,):
                    key = x_var.name
                else:
                    key = x_var.name + str(j[0])
                bounds[key] = 0.05*x_var[(1,3)+j].value
            
        # run sIpopt
        sIP = SolverFactory('ipopt_sens', solver_io = 'nl')
        #sIP.options['run_sens'] = 'yes'
        #sIP.options['n_sens_steps'] = 2
        #sIP.options['tol'] = 1e-5
        sIP.options["halt_on_ampl_error"] = "yes"
        #sIP.options["print_user_options"] = "yes"
        #sIP.options["linear_solver"] = "ma57"
        with open("ipopt.opt", "w") as f:
            f.write('run_sens yes \n n_sens_steps 8 \n tol 1e-5 \n print_user_options yes \n linear_solver ma57')
            f.close()
        #m.write('test.nl')
        results = sIP.solve(m, tee = True)
        m.solutions.load_from(results)
        
        # compute finite difference approximation of sensitivities, first with respect to endpoint constraints only
        sens = {} # dictionary that contains the sensitivities organized like {('slack_var','parameter'):value}
        constraints = ['s_mw','s_PO_ptg','s_unsat']
        p = 1

        for key in state_suffix_map:
            p = state_suffix_map[key]
            print(p)
            print(key)
            for con in constraints:
                rhs_0 = getattr(m, con)
                solution_suffix = getattr(m,'sens_sol_state_' + str(p))
                rhs_perturbed = solution_suffix.get(rhs_0[1])
                delta_rhs =  rhs_perturbed - rhs_0[1].value
                sens[(con,key)] = delta_rhs/delta_p 
    
        # assemble LP 
        self.lp = m.assemble_lp(sens,bounds)
        
        # solve LP wih Ipopt and find worst case scenario
        ip = SolverFactory('ipopt')
        ip.options["halt_on_ampl_error"] = 'yes'
        with open("ipopt.opt", "w") as f:
            f.write('\n tol 1e-5 \n print_user_options yes \n linear_solver ma57')
            f.close()
        
        results = ip.solve(self.lp,tee = True)
        
        return sens
